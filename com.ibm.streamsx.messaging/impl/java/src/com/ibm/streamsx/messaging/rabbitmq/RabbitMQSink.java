/*******************************************************************************
 * Copyright (C) 2015, MOHAMED-ALI SAID
 * All Rights Reserved
 *******************************************************************************/
/* Generated by Streams Studio: March 26, 2014 11:37:11 AM EDT */
package com.ibm.streamsx.messaging.rabbitmq;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

import org.slf4j.LoggerFactory;

import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.StreamingData.Punctuation;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPorts;
import com.ibm.streams.operator.model.PrimitiveOperator;
import com.rabbitmq.client.AMQP.BasicProperties;
import com.rabbitmq.client.AlreadyClosedException;

/**
 * This operator was originally contributed by Mohamed-Ali Said @saidmohamedali
 * Class for an operator that consumes tuples and does not produce an output
 * stream. This pattern supports a number of input streams and no output
 * streams.
 * <P>
 * The following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to
 * process and submit tuples</li>
 * <li>process() handles a tuple arriving on an input port
 * <li>processPuncuation() handles a punctuation mark arriving on an input port
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any
 * time, such as a request to stop a PE or cancel a job. Thus the shutdown() may
 * occur while the operator is processing tuples, punctuation marks, or even
 * during port ready notification.</li>
 * </ul>
 * <p>
 * With the exception of operator initialization, all the other events may occur
 * concurrently with each other, which lead to these methods being called
 * concurrently by different threads.
 * </p>
 */
@InputPorts(@InputPortSet(cardinality = 1, optional = false, description = ""))
@PrimitiveOperator(name = "RabbitMQSink", description = "something")
public class RabbitMQSink extends RabbitBaseOper {

	private static final org.slf4j.Logger log = LoggerFactory
			.getLogger(RabbitMQSink.class);

	/**
	 * Initialize this operator. Called once before any tuples are processed.
	 * 
	 * @param context
	 *            OperatorContext for this operator.
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public synchronized void initialize(OperatorContext context)
			throws Exception {

		// Must call super.initialize(context) to correctly setup an operator.
		super.initialize(context);
		super.initSchema(getInput(0).getStreamSchema());
		log.trace("Operator " + context.getName() + " initializing in PE: "
				+ context.getPE().getPEId() + " in Job: "
				+ context.getPE().getJobId());

	}

	/**
	 * Notification that initialization is complete and all input and output
	 * ports are connected and ready to receive and submit tuples.
	 * 
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public synchronized void allPortsReady() throws Exception {
		// This method is commonly used by source operators.
		// Operators that process incoming tuples generally do not need this
		// notification.
		OperatorContext context = getOperatorContext();
		log.trace("Operator " + context.getName()
				+ " all ports are ready in PE: " + context.getPE().getPEId()
				+ " in Job: " + context.getPE().getJobId());

	}

	/**
	 * Process an incoming tuple that arrived on the specified port.
	 * 
	 * @param stream
	 *            Port the tuple is arriving on.
	 * @param tuple
	 *            Object representing the incoming tuple.
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public void process(StreamingInput<Tuple> stream, Tuple tuple)
			{

		String message = tuple.getString(messageAH.getName());
		String routingKey = tuple.getString(routingKeyAH.getName());

		try {
			log.trace("Producing message: " + message + " in thread: "
					+ Thread.currentThread().getName());
			BasicProperties.Builder propsBuilder = new BasicProperties.Builder();
			Map<String, Object> headers = new HashMap<String,Object>();
			headers.put("test", "myHeader");
			propsBuilder.headers(headers);
			channel.basicPublish(exchangeName, routingKey, propsBuilder.build(),
					message.getBytes());
		} catch (Exception e) {
			log.trace("Exception message:" + e.getMessage() + "\r\n");
		} 
	}

	/**
	 * Process an incoming punctuation that arrived on the specified port.
	 * 
	 * @param stream
	 *            Port the punctuation is arriving on.
	 * @param mark
	 *            The punctuation mark
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public void processPunctuation(StreamingInput<Tuple> stream,
			Punctuation mark) throws Exception {
	}

	/**
	 * Shutdown this operator.
	 * 
	 * @throws TimeoutException
	 * @throws IOException
	 */
	@Override
	public synchronized void shutdown() throws IOException, TimeoutException {
		super.shutdown();
	}

}

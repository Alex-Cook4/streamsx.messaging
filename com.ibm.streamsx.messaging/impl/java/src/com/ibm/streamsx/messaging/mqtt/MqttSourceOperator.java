/*******************************************************************************
 * Licensed Materials - Property of IBM
 * Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 *******************************************************************************/
/* Generated by Streams Studio: 28 February, 2014 3:11:52 PM EST */
package com.ibm.streamsx.messaging.mqtt;


import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;

import org.apache.log4j.Logger;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;

import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OutputTuple;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.StreamingOutput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.log4j.TraceLevel;
import com.ibm.streams.operator.model.Libraries;
import com.ibm.streams.operator.model.OutputPortSet;
import com.ibm.streams.operator.model.InputPortSet.WindowMode;
import com.ibm.streams.operator.model.InputPortSet.WindowPunctuationInputMode;
import com.ibm.streams.operator.model.OutputPortSet.WindowPunctuationOutputMode;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPorts;
import com.ibm.streams.operator.model.OutputPorts;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;
import com.ibm.streams.operator.types.ValueFactory;

/**
 * A source operator that does not receive any input streams and produces new tuples. 
 * The method <code>produceTuples</code> is called to begin submitting tuples.
 * <P>
 * For a source operator, the following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to process and submit tuples</li> 
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any time, 
 * such as a request to stop a PE or cancel a job. 
 * Thus the shutdown() may occur while the operator is processing tuples, punctuation marks, 
 * or even during port ready notification.</li>
 * </ul>
 * <p>With the exception of operator initialization, all the other events may occur concurrently with each other, 
 * which lead to these methods being called concurrently by different threads.</p> 
 */
@PrimitiveOperator(name="MQTTSource", namespace="com.ibm.streamsx.messaging.mqtt",
description="Java Operator MqttSourceOperator")
@InputPorts({@InputPortSet(description="Optional input ports", optional=true, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious)})
@OutputPorts({@OutputPortSet(description="Port that produces tuples.", cardinality=1, optional=false, windowPunctuationOutputMode=WindowPunctuationOutputMode.Free), @OutputPortSet(description="Optional output ports", optional=true, windowPunctuationOutputMode=WindowPunctuationOutputMode.Free)})
@Libraries(value = {"opt/mqtt/*"})
public class MqttSourceOperator extends AbstractOperator {
	
	private static Logger TRACE = Logger.getLogger(MqttSourceOperator.class);
	
	// Parameters
	private List<String> topics;
	private int[] qos;
	private String serverUri;
	private String topicOutAttrName;
	
	private int reconnectionBound = IMqttConstants.DEFAULT_RECONNECTION_BOUND;		// default 5, 0 = no retry, -1 = infinite retry
	private float period = IMqttConstants.DEFAULT_RECONNECTION_PERIOD;
	

	private MqttClientWrapper mqttWrapper;
	private boolean shutdown = false;
	
	private ArrayBlockingQueue<MqttMessageRecord> messageQueue;

	/**
	 * Thread for calling <code>produceTuples()</code> to produce tuples 
	 */
    private Thread processThread;
    
    
    private class MqttMessageRecord {
    	String topic;
    	MqttMessage message;
    	
    	public MqttMessageRecord(String topic, MqttMessage message) {
    		this.topic = topic;
    		this.message = message;
		}
    }
    
    
    private MqttCallback callback = new MqttCallback() {

		@Override
		public void connectionLost(Throwable cause) {
			try {
				connectAndSubscribe();
			} catch (MqttException e) {
				TRACE.error("Reconnection failed.", e);
			} catch (InterruptedException e) {
				TRACE.error("Reconnection failed.", e);
			}
		}

		@Override
		public void messageArrived(String topic, MqttMessage message)
				throws Exception {
			
			MqttMessageRecord record = new MqttMessageRecord(topic, message);
			messageQueue.put(record);					
		}

		@Override
		public void deliveryComplete(IMqttDeliveryToken token) {		
			
		}    	
    	
    };
    

    /**
     * Initialize this operator. Called once before any tuples are processed.
     * @param context OperatorContext for this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void initialize(OperatorContext context)
            throws Exception {
    	// Must call super.initialize(context) to correctly setup an operator.
        super.initialize(context);
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        messageQueue = new ArrayBlockingQueue<MqttSourceOperator.MqttMessageRecord>(50);
        
        mqttWrapper = new MqttClientWrapper();
        mqttWrapper.setBrokerUri(serverUri);
        connectAndSubscribe();
        
        /*
         * Create the thread for producing tuples. 
         * The thread is created at initialize time but started.
         * The thread will be started by allPortsReady().
         */
        processThread = getOperatorContext().getThreadFactory().newThread(
                new Runnable() {

                    @Override
                    public void run() {
                        try {
                            produceTuples();
                        } catch (Exception e) {
                            Logger.getLogger(this.getClass()).error("Operator error", e);
                        }                    
                    }
                    
                });
        
        /*
         * Set the thread not to be a daemon to ensure that the SPL runtime
         * will wait for the thread to complete before determining the
         * operator is complete.
         */
        processThread.setDaemon(false);
    }

	private void connectAndSubscribe() throws MqttException, InterruptedException {
		mqttWrapper.connect(getReconnectionBound(), getPeriod());
        mqttWrapper.addCallBack(callback);               
        
        // qos is an optional parameter, set up defaults if it is not specified
        if (qos == null)
        {
        	qos = new int[topics.size()];
        	for (int i = 0; i < qos.length; i++) {
				qos[i] = 0;
			}
        }
        
        mqttWrapper.subscribe((String[])topics.toArray(new String[0]), qos);
	}

    /**
     * Notification that initialization is complete and all input and output ports 
     * are connected and ready to receive and submit tuples.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void allPortsReady() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    	// Start a thread for producing tuples because operator 
    	// implementations must not block and must return control to the caller.
        processThread.start();
    }
    
    /**
     * Submit new tuples to the output stream
     * @throws Exception if an error occurs while submitting a tuple
     */
    private void produceTuples() throws Exception  {
        while (!shutdown)
        {
        	MqttMessageRecord record = messageQueue.take();
			byte[] blob = record.message.getPayload();
			
			StreamingOutput<OutputTuple> outputPort = getOutput(0);
			OutputTuple tuple = outputPort.newTuple();
			tuple.setBlob(0, ValueFactory.newBlob(blob));
			
			if (topicOutAttrName != null)
			{
				tuple.setString(topicOutAttrName, record.topic);
			}
			
			outputPort.submit(tuple);
        }
    }
    
    @Override
    public void process(StreamingInput<Tuple> stream, Tuple tuple)
    		throws Exception {
    	handleControlSignal(tuple);
    }
    
	private void handleControlSignal(Tuple tuple) {
		// handle control signal to switch server
		try {
			Object object = tuple.getMap("mqttConfig");
			TRACE.log(TraceLevel.DEBUG, "[Control Port:] object: " + object + " " + object.getClass().getName()); //$NON-NLS-1$ //$NON-NLS-2$

			if (object instanceof Map)
			{									
				Map map = (Map)object;
				Set keySet = map.keySet();
				for (Iterator iterator = keySet.iterator(); iterator
						.hasNext();) {
					Object key = (Object) iterator.next();
					TRACE.log(TraceLevel.DEBUG, "[Control Port:] " + key + " " + key.getClass()); //$NON-NLS-1$ //$NON-NLS-2$
					
					String keyStr = key.toString();
					
					// case insensitive checks
					if (keyStr.toLowerCase().equals(IMqttConstants.CONN_SERVERURI.toLowerCase()))
					{
						Object serverUri = map.get(key);				
						
						String serverUriStr = serverUri.toString();
						
						// only handle if server URI has changed
						if (!serverUriStr.toLowerCase().equals(getServerUri().toLowerCase()))
						{						
							TRACE.log(TraceLevel.DEBUG, "[Control Port:] " + IMqttConstants.CONN_SERVERURI + ":" + serverUri); //$NON-NLS-1$ //$NON-NLS-2$
						
							setServerUri(serverUriStr);
							mqttWrapper.setBrokerUri(serverUriStr);
							
							// disconnect and try to connect again.
							// Disconnect is synchronous so wait for that to finish and attempt to connect.
							mqttWrapper.disconnect();
							connectAndSubscribe();	
						}
					}					
				}
			}
		} catch (Exception e) {
			TRACE.log(TraceLevel.ERROR, Messages.getString("MqttSinkOperator.21")); //$NON-NLS-1$
		}
	}

    /**
     * Shutdown this operator, which will interrupt the thread
     * executing the <code>produceTuples()</code> method.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    public synchronized void shutdown() throws Exception {
    	
    	shutdown = true;
    	
        if (processThread != null) {
            processThread.interrupt();
            processThread = null;
        }
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        mqttWrapper.disconnect();
        mqttWrapper.shutdown();

        // Must call super.shutdown()
        super.shutdown();
    }
    
    @Parameter(name="topics", description="List of topics to subscribe to.", optional=false, cardinality=-1)
	public void setTopics(List<String> topics) {
		this.topics = topics;
	}

    @Parameter(name="qos", description="List of qos for topic subscriptions", optional=true, cardinality=-1)
	public void setQos(int[] qos) {
		this.qos = qos;
	}

    @Parameter(name="serverURI", description="Server to subscribe messages from.", optional=false)
	public void setServerUri(String serverUri) {
		this.serverUri = serverUri;
	}
	
	public List<String> getTopics() {
		return topics;
	}

	public int[] getQos() {
		return qos;
	}

	public String getServerUri() {
		return serverUri;
	}
	
	 @Parameter(name="topicOutAttrName", description="Output attribute on output data stream to assign message topic to.", optional=true)
	public void setTopicOutAttrName(String topicOutAttrName) {
		this.topicOutAttrName = topicOutAttrName;
	}
	
	public String getTopicOutAttrName() {
		return topicOutAttrName;
	}
	
	@Parameter(name="reconnectionBound", description="Reconnection bound, 0 for no retry, n for n number of retries, -1 for inifinite retry.", optional=true)
	public void setReconnectionBound(int reconnectionBound) {
		this.reconnectionBound = reconnectionBound;
	}
	
	@Parameter(name="period", description="Reconnection period, default is 60 s.", optional=true)
	public void setPeriod(float period) {
		this.period = period;
	}
	
	public int getReconnectionBound() {
		return reconnectionBound;
	}
	
	public float getPeriod() {
		return period;
	}
}

/* Generated by Streams Studio: March 26, 2014 2:09:26 PM EDT */
/*******************************************************************************
* Copyright (C) 2015, MOHAMED-ALI SAID
* All Rights Reserved
*******************************************************************************/
package com.ibm.streamsx.messaging.rabbitmq;


//import org.apache.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.TimeoutException;

import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OutputTuple;
import com.ibm.streams.operator.StreamingOutput;
import com.ibm.streams.operator.model.Libraries;
import com.ibm.streams.operator.model.OutputPortSet;
import com.ibm.streams.operator.model.OutputPorts;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;

import com.ibm.streamsx.messaging.rabbitmq.UpdateEvent;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Envelope;

import org.slf4j.LoggerFactory;
/**
 * This operator was originally contributed by Mohamed-Ali Said @saidmohamedali
 * A source operator that does not receive any input streams and produces new tuples. 
 * The method <code>produceTuples</code> is called to begin submitting tuples.
 * <P>
 * For a source operator, the following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to process and submit tuples</li> 
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any time, 
 * such as a request to stop a PE or cancel a job. 
 * Thus the shutdown() may occur while the operator is processing tuples, punctuation marks, 
 * or even during port ready notification.</li>
 * </ul>
 * <p>With the exception of operator initialization, all the other events may occur concurrently with each other, 
 * which lead to these methods being called concurrently by different threads.</p> 
 */
@OutputPorts(@OutputPortSet(cardinality=1, optional=false, 
description="Messages received from Kafka are sent on this output port."))
@PrimitiveOperator(name="RabbitMQSource", description="something")
public class RabbitMQSource extends RabbitBaseOper implements UpdateEvent {

	public static final String EXCHANGENAME_PARAM = "exchangeName";
	public static final String ROUTINGKEY_PARAM = "routingKey";
	public static final String USERNAME_PARAM="userName";
	public static final String PASSWORD_PARAM="password";
	public static final String HOSTNAME_PARAM="hostName";
	public static final String PORTID_PARAM="portId";

	//private RabbitMQWrapper rabbitMQWrapper;
	//private String exchangeNameParam, routingKeyParam,userNameParam,passwordParam,hostNameParam;
	//private int portIdParam;
	
	private static final org.slf4j.Logger log = LoggerFactory.getLogger(RabbitMQSource.class);
	/**
	 * Thread for calling <code>produceTuples()</code> to produce tuples 
	 */
    private Thread processThread;

    /**
     * Initialize this operator. Called once before any tuples are processed.
     * @param context OperatorContext for this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void initialize(OperatorContext context)
            throws Exception {
    	// Must call super.initialize(context) to correctly setup an operator.
        super.initialize(context);
        super.initSchema(getOutput(0).getStreamSchema());
        log.trace(this.getClass().getName()+"Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        // TODO:
        // If needed, insert code to establish connections or resources to communicate an external system or data store.
        // The configuration information for this may come from parameters supplied to the operator invocation, 
//        // or external configuration files or a combination of the two.
//        rabbitMQWrapper = new RabbitMQWrapper(this,exchangeName,routingKey);
//        rabbitMQWrapper.login(username, password, hostName, portId);
        if (queueName == ""){
        	queueName = channel.queueDeclare().getQueue();
        }
        
        channel.queueBind(queueName, exchangeName, routingKey);
        System.out.println("Queue: " + queueName + " Exchange: " + exchangeName);
        //produce tuples returns immediately, but we don't want ports to close
        createAvoidCompletionThread();
        
        /*
         * Create the thread for producing tuples. 
         * The thread is created at initialize time but started.
         * The thread will be started by allPortsReady().
         */
        processThread = getOperatorContext().getThreadFactory().newThread(
                new Runnable() {

                    @Override
                    public void run() {
                        try {
                        	produceTuples();
                            //rabbitMQWrapper.Consume();
                        } catch (Exception e) {
                           e.printStackTrace(); // Logger.getLogger(this.getClass()).error("Operator error", e);
                        }                    
                    }
                    
                });
        
        /*
         * Set the thread not to be a daemon to ensure that the SPL runtime
         * will wait for the thread to complete before determining the
         * operator is complete.
         */
        processThread.setDaemon(false);
    }

    /**
     * Notification that initialization is complete and all input and output ports 
     * are connected and ready to receive and submit tuples.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void allPortsReady() throws Exception {
        OperatorContext context = getOperatorContext();
        //Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    	// Start a thread for producing tuples because operator 
    	// implementations must not block and must return control to the caller.
        processThread.start();
    }
    
    /**
     * Submit new tuples to the output stream
     * @throws Exception if an error occurs while submitting a tuple
     */
    private void produceTuples() throws Exception  {
    	System.out.println("Producing tuples!");
		Consumer consumer = new DefaultConsumer(channel) {
			@Override
			public void handleDelivery(String consumerTag, Envelope envelope,
					AMQP.BasicProperties properties, byte[] body)
					throws IOException {
				String message = new String(body, "UTF-8");
				StreamingOutput<OutputTuple> out = getOutput(0);
				OutputTuple tuple = out.newTuple();
				if (routingKeyAH.isAvailable()){
					tuple.setString(routingKeyAH.getName(), envelope.getRoutingKey());
					System.out.println(routingKeyAH.getName() + ":" + envelope.getRoutingKey());
				} else {
					System.out.println("What the hell?? " + routingKeyAH.toString());
				}
				tuple.setString(messageAH.getName(),message);
				System.out.println("message: " + message);
				// Submit tuple to output stream
				try {
					out.submit(tuple);
				} catch (Exception e) {
					System.out.println("Catching submit exception");
					e.printStackTrace();
				}
			}
		};
	    channel.basicConsume(queueName, true, consumer);
        // TODO If there is a finite set of tuples, submit a final punctuation when finished
        // by uncommenting the following line:
        // out.punctuate(Punctuation.FINAL_MARKER);
    }
    
    public void NotifyUpdateEvent (String guid, String message){
    	try {
           
    	final StreamingOutput<OutputTuple> out = getOutput(0);
        
        // TODO Modify the following code to create and submit tuples to the output port
        OutputTuple tuple = out.newTuple();
            
        // Set attributes in tuple:
        // tuple.setString("AttributeName", "AttributeValue");
        if (!guid.isEmpty())
        	tuple.setString(routingKeyAH.getName(),guid);
   	    tuple.setString(messageAH.getName(),message);
        // Submit tuple to output stream            
        out.submit(tuple);

        } catch (Exception e) {
        	System.out.println("Exception: " + e);
           //log. Logger.getLogger(this.getClass()).error("Operator error", e);
        }  
    }
    
//    @Parameter(optional=true, description="Exchange Name.")
//	public void setExchangeName(String value) {
//		exchangeNameParam = value;
//	}
//    
//    @Parameter(optional=true, description="Exchange Name.")
//	public void setRoutingKey(String value) {
//		routingKeyParam = value;
//	}
//    
//    @Parameter(optional=true, description="Exchange Name.")
//	public void setUsername(String value) {
//		userNameParam = value;
//	}
//    
//    @Parameter(optional=true, description="Exchange Name.")
//	public void setPassword(String value) {
//		passwordParam = value;
//	}
//    
//    @Parameter(optional=true, description="Exchange Name.")
//	public void setHostname(String value) {
//		hostNameParam = value;
//	}
//    
//    @Parameter(optional=true, description="Exchange Name.")
//	public void setPortId(int value) {
//		portIdParam = value;
//	}

    /**
     * Shutdown this operator, which will interrupt the thread
     * executing the <code>produceTuples()</code> method.
     * @throws TimeoutException 
     * @throws IOException 
     */
    public synchronized void shutdown() throws IOException, TimeoutException {
    	//rabbitMQWrapper.logout();
        if (processThread != null) {
            processThread.interrupt();
            processThread = null;
        }
        OperatorContext context = getOperatorContext();
      //  Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO: If needed, close connections or release resources related to any external system or data store.

        // Must call super.shutdown()
        super.shutdown();
    }
}
